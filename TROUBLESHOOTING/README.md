# HOMEWORK_TROUBLESHOOTING_6_6_(VITKIN_K_N)

### 1. 
- *Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать*
- *Напишем список операций, для остановки запроса пользователя:*

```
MongoDB предоставляет два средства для завершения запущенных операций: maxTimeMS() и db.killOp(). Используйте эти операции по мере необходимости, чтобы контролировать поведение операций в развертывании MongoDB.
Доступные процедуры
Метод db.killOp() прерывает текущую операцию в следующей точке прерывания. db.killOp() идентифицирует целевую операцию по идентификатору операции.
db.killOp(<opId>)
ПРЕДУПРЕЖДЕНИЕ
Прекращайте текущие операции с особой осторожностью. Используйте db.killOp() только для завершения операций, инициированных клиентами, и не прерывайте внутренние операции базы данных.
Разделенный кластер
Начиная с MongoDB 4.0, команда killOp может выполняться на mongos и может уничтожать запросы (то есть операции чтения), которые охватывают осколки в кластере. Команда killOp от монго не распространяется на осколки, когда операция, которая должна быть уничтожена, является операцией записи.
Определяем opId и делаем db.killOp(<opId>)
```
- *Вариант решения проблемы с долгими (зависающими) запросами в MongoDB*
```
maxTimeMS
Метод maxTimeMS() устанавливает ограничение по времени для операции. Когда операция достигает указанного предела времени, MongoDB прерывает операцию в следующей точке прерывания.
db.location.find( { "town": { "$regex": "(Pine Lumber)",
                              "$options": 'i' } } ).maxTimeMS(30)
```
___
### 2. 
- *Инстанс Redis запущен совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.*
- *При масштабировании сервиса до N реплик вы увидели, что: сначала рост отношения записанных значений к истекшим; Redis блокирует операции записи*

```
Еще один источник задержки связан с поддержкой Redis только для добавления файлов. AOF в основном использует два системных вызова для выполнения своей работы. Один из них — write(2), который используется для записи данных в файл только для добавления, а другой — fdatasync(2), который используется для очистки буфера файла ядра на диске, чтобы обеспечить заданный уровень устойчивости. пользователем
Еще одна вероятная причина блокировки записи может быть очень быстро удаляемыми ключами - основывается запись блокируется до закрытия процесса извлечения ключей:
«если в базе данных есть много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы процент ключей, срок действия которых уже истек, был ниже 25%.
Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек, и обычно абсолютно безвреден, так как странно, что срок действия большого количества ключей истекает в одну и ту же секунду, но не исключено, что пользователь активно использовал EXPIREAT с тем же временем Unix.
Многие ключи, срок действия которых истекает в один и тот же момент, могут быть источником задержки».
```

### 3.
- *Поднята база данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:*
```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
- *почему это начало происходить и как локализовать проблему?*
```
Иногда данная форма , когда миллионы строк отправляются как часть одного или нескольких запросов. Если мы знаем, что это происходит, то нам следует попробовать увеличить значение net_read_timeout с 30 секунд по умолчанию до 60 секунд или более, достаточного для завершения передачи данных.
Реже это может произойти, когда клиент пытается установить первоначальное соединение с сервером. В этом случае, если наше значение connect_timeout установлено всего на несколько секунд, мы можем решить проблему, увеличив его до десяти секунд, возможно, больше, если у нас очень большое расстояние или медленное соединение. Мы можете определить причину, используя SHOW GLOBAL STATUS LIKE 'Aborted_connects'. Он будет увеличиваться на единицу за каждую первоначальную попытку подключения, которую прерывает сервер. Мы можем увидеть «чтение пакета авторизации» как часть сообщения об ошибке; если это так, это также говорит о том, что это решение, которое вам нужно.
Если причина не в одной из только что описанных, у вас может возникнуть проблема со значениями BLOB, превышающими max_allowed_packet, что может вызвать эту ошибку на некоторых клиентах. Иногда мы можем увидеть ошибку ER_NET_PACKET_TOO_LARGE, и это подтверждает, что нам нужно увеличить max_allowed_packet.
```

___
### 4.
- *Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.*
- *СУБД время от времени становится недоступной. В dmesg вы видите, что:*
```
postmaster invoked oom-killer
```
- *то происходит? Как бы вы решили данную проблему?*
```
Когда у сервера или процесса заканчивается память, Linux предлагает 2 пути решения: обрушить всю систему или завершить процесс (приложение), который съедает память. Лучше, конечно, завершить процесс и спасти ОС от аварийного завершения. В двух словах, Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.
Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту, и этим поведением управляет параметр ядра Linux. За это отвечает переменная vm.overcommit_memory
Чтобы не приходилось использовать OOM-Killer для завершения PostgreSQL, установим для vm.overcommit_memory значение 2. Это не гарантирует, что OOM-Killer не придется вмешиваться, но снизит вероятность принудительного завершения процесса PostgreSQL.
```